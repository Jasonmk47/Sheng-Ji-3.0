
type User {
  userId: ID!
  username: String!
}

type Match {
  matchId: Int!
  isActive: Boolean!
  userIds: [ID!]!
  userLevels: [Int!]!
  defenderUserIds: [ID!]
  currentGame: Game!
}

# Game is user specific
type Game {
  gameId: Int!
  matchId: Int!
  isActive: Boolean!
  trumpSuit: Int!
  trumpNumber: Int
  startingUserId: ID
  currentPoints: Int
  hand: [Int!]!
}

type Trick {
  trickId: Int!
  gameId: Int!
  orderId: Int!
  startingUserId: ID!
  winningUserId: ID
  playedCardIds: [Int!]!
  playType: Int!
}

# the schema allows the following query:
type Query {
  allUsers(userId: ID!):[User!]
  user(userId: ID!): User
  game(gameId: Int!, userId: ID!): Game  # why do we need userID?
  match(matchId: Int!, userId: ID!): Match
  trick(trickId: Int!): Trick
  activeGame(matchId: Int!, userId: ID!): Game
  activeMatches(userId: ID!): [Match!]!
  allGames(userId: ID!): [Game!]
  allMatches(userId: ID!): [Match!]
  allMatchGames(matchId: Int!, userId: ID!): [Game!]
}

# this schema allows the following mutation:
type Mutation {
  playCard(userId: ID!, cardId: Int!, gameId: Int!): Game
}

schema {
  query: Query
  mutation: Mutation
}
